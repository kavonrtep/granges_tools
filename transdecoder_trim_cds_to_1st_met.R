#!/usr/bin/env Rscript
library(optparse)
parser <- OptionParser()
option_list <- list(
  make_option(c("-g", "--gff3"), action = "store", type = "character",
              help = "gff3 from transdecoder - contain cooridated related to transcriopt!", default = NULL),
  make_option(c("-s", "--transcripts"), action = "store", type = "character",
              help = "transcriptome fasta file", default = NULL),
  make_option(c("-o", "--output"), action = "store", type = "character",
              help = "output base name for gff with modified CDS coordinate and fasta with petides", default = NULL)

)
description <- "
This script takes transcript in fasta format generated by stringtie and its annotation
which was created by transdecoder. Some of the annotated CDS does not start with
Met codon. This script adjust the CDS start to the first Met. Output gff3 transcript
annotation can be then used to create gff3 genome annotation with corrected CDS
using transdecoder script:

cdna_alignment_orf_to_genome_orf.pl transcriptome_cds_corrected.gff3 \
     stringtie_genome_annotation.gff3 \
     transcripts.fasta \
     > genome_annotation_with_CDS.gff3
"

epilogue <- ""
parser <- OptionParser(option_list = option_list, epilogue = epilogue, description = description,
                       usage = "usage: %prog COMMAND [OPTIONS]")
opt <- parse_args(parser, args = commandArgs(TRUE))

if (any(is.null(opt$gff3),
        is.null(opt$transcripts),
        is.null(opt$output)
)){
  print_help(parser)
  stop('all argument are required!')
}

suppressPackageStartupMessages({
  library(rtracklayer)
  library(Biostrings)
  library(BSgenome)
})


g <- import(opt$gff3)
s <- readDNAStringSet(opt$transcripts)

# for testing
if (FALSE){
  g <- import("/mnt/raid/454_data/cuscuta/Ceuropea_assembly_v4/0_final_hifiasm_20211203/stringtie_v2/annotation_stringtie_conservative_transcripts.fasta.transdecoder.gff3")
  s <- readDNAStringSet("/mnt/raid/454_data/cuscuta/Ceuropea_assembly_v4/0_final_hifiasm_20211203/stringtie_v2/annotation_stringtie_conservative_transcripts.fasta")

}

names(s) <- gsub(" .+", "", names(s))
g_cds <-  g[g$type == "CDS"]

CDS <-  getSeq(s,g_cds)
pep <-  translate(CDS, no.init.codon = TRUE)
# statistics:
stats = list(
  "total_cds                  " = length(pep),
  "cds_start_with_Met         " = sum(substr(pep,1,1) == "M"),
  "cds_does_not_start_with_met" = sum(substr(pep,1,1) != "M")
)
# print statistics
cat("CDS statistics:\n")
. <-  Map(function(x, n)cat(n, ':', x, "\n"), stats, names(stats))

first_Met <- regexpr("M", as.character(pep))
adjusted_position_start <- ifelse(strand(g_cds) == "+", start(g_cds) + (first_Met - 1) * 3 , start(g_cds))
adjusted_position_end <- ifelse(strand(g_cds) == "-", end(g_cds) - (first_Met - 1) * 3 , end(g_cds))

# check if ranges are correct
cond1 <- adjusted_position_end > adjusted_position_start
SL <- nchar(s[match(as.character(seqnames(g_cds)), names(s))])
cond2 <- adjusted_position_start > 0
cond3 <- adjusted_position_end <= SL
g_cds_adjusted <- g_cds
start(g_cds_adjusted) <- adjusted_position_start
end(g_cds_adjusted) <- adjusted_position_end
g_cds_adjusted_ok <- g_cds_adjusted[cond1 & cond2 & cond3]


pep_adjusted <- translate(getSeq(s, g_cds_adjusted_ok))
names(pep_adjusted) <- g_cds_adjusted_ok$ID

# export adjusted data
g_adjusted <- sort(append(g[g$type != 'CDS'], g_cds_adjusted_ok))
export(g_adjusted, paste0(opt$output, ".gff3"), format = 'gff3')
writeXStringSet(pep_adjusted, filepath = paste0(opt$output, ".pep"))
